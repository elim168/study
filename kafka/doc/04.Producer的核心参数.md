# Producer的核心参数

定义KafkaProducer时是可以定义一系列的参数的，主要参数有如下这些。

* bootstrap.servers：用来指定Kafka服务器的地址，格式是`host:port`，多个地址之间通过英文逗号分隔。如果你需要连接的不是单Kafka服务，而是一个Kafka集群，那么你不需要通过`bootstrap.servers`指定集群中所有Kafka的地址，而只需要指定其中的一些，Kafka客户端只需要通过集群中的一台机器即可获取到整个集群的地址。但是此时往往你也不能只定义其中的一个地址，因为如果你指定的那个地址的Kafka刚好挂掉了则你就连接不是整个集群了。
* acks：当Kafka服务是一个集群时，是可以针对Topic指定多个副本的，有多个副本时主节点与从节点之间需哟进行消息同步。acks用来指定Producer发送消息到了Kafka服务器后，Kafka服务器需要与多少个从节点之间进行了消息同步后才响应Producer认为此消息发送成功。如果指定`acks=0`则表示不需要任何反馈，只要消息放到了发送队列中即认为发送成功，而不管Kafka服务器是否真的收到了对应的消息。指定`acks=1`时表示只要Kafka服务器收到消息写入了本地文件即认为发送成功，就会响应给客户端，而不需要等待主节点与其它从节点之间的同步，因为主节点也算一个副本。这种情况如果主节点告诉客户端消息发送成功了，然后在消息还没有同步到任何从节点之前主节点挂了，则该消息将丢失。指定`acks=2`则表示Kafka服务器收到消息后还需要等待至少一个从节点同步消息成功后才能响应给客户端消息发送成功。如果需要消息同步到所有的从节点，则指定`acks=all`，这种情况只要集群中有一个副本节点还存活即不会出现消息丢失。
* key.serializer：指定Key需要使用的序列化实现。
* value.serializer：指定Value需要使用的序列化实现。
* buffer.memory：Producer进行消息发送时是会先在内存里面进行缓冲的，buffer.memory就用来定义缓冲区的大小，单位是字节，默认是33554432字节，即32MB。如果Producer发送消息到缓冲区的速度比消息投递到Kafka服务器的速度快很多，那么缓冲区会不断的塞满，再有消息来的时候Producer将进行阻塞，阻塞的最大时间由`max.block.ms`指定，超过了那个时间之后就将抛出异常。
* compression.type：指定数据的压缩方式，默认是none。可选值有none/gzip/snappy/lz4/zstd。
* retries：用来指定当消息发送失败时进行重试的次数，默认是2147483647，即无限重试，此时将由超时时间来阻止无限的重试下去。官方推荐我们不指定该参数，而是指定超时时间。
* delivery.timeout.ms：指定消息从产生到成功投递到Kafka服务器的超时时间，包括客户端收到服务端响应消息的时间，还包括消息重试发送的时间。
* ssl.keystore.location：可选配置。指定Keystore的路径。
* ssl.keystore.password：可选配置，Keystore的密码。
* ssl.key.password：可选配置，Keystore中私钥的密码。
* ssl.truststore.location：指定Trust Store的位置。
* ssl.truststore.password：指定Trust Store的密码。
* batch.size：当Producer需要发送大量消息时，如果每发一条消息都向Kafka服务器发送一次请求效率会比较低。当一个Producer需要发送大量消息到同一个Topic的同一个分区时，Producer会把多条消息合并在一起进行发送，这样可以拥有更少的请求，在相同的时间内可以发送更多的消息，因为少了一部分网络时长。`batch.size`用来限制一个批次的消息的最大容量，单位是字节，默认是16384，即16KB。如果设置`batch.size`的值为0,则每条消息都将作为一个独立的批次发送到Kafka服务器。如果这个值设置的太大，可能会造成一些内存的浪费，因为对应的内存会预先分配。
* client.id：指定客户端的一个标识。该标识将在向Kafka服务器发送请求时传递给服务端，可以用来进行请求追踪。
* connections.max.idle.ms：闲置连接的最大闲置时间。


