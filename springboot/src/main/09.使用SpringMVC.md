# 使用SpringMVC

使用SpringMVC最简单的方法是在`pom.xml`中加入`spring-boot-starter-web`依赖，这样Spring Boot的AutoConfiguration模块将为我们自动进行SpringMVC的配置，创建好`RequestMappingHandlerAdapter`、`RequestMappingHandlerMapping`等，详情可以参考`org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration`和`DelegatingWebMvcConfiguration`的源码。

这个时候就可以定义如下这样一个控制器，当请求`/hello/json`时将返回`{"key1": "value1", "key2": "value2"}`这样一段JSON。当Classpath下存在jackson相关的Class时就会自动添加`MappingJackson2HttpMessageConverter`这样一个`HttpMessageConverter`。关于默认添加的`HttpMessageConverter`可以参考`WebMvcConfigurationSupport`的`addDefaultHttpMessageConverters()`的源码说明。

```java
@RestController
@RequestMapping("hello")
public class HelloController {

    @GetMapping("json")
    public Object jsonResult() {
        Map<String, Object> map = new HashMap<>();
        map.put("key1", "value1");
        map.put("key2", "value2");
        return map;
    }
    
}
```

## 添加自定义的HttpMessageConverter

添加自定义的`HttpMessageConverter`比较方便的方法是通过`org.springframework.boot.autoconfigure.http.HttpMessageConverters`定义，它可以在指定使用默认的`HttpMessageConverter`的同时添加额外的`HttpMessageConverter`。下面的代码中就指定了在使用默认的`HttpMessageConverter`的同时添加了一个自定义的`CustomHttpMessageConverter`。

@Configuration
public class MvcConfiguration {

    @Bean
    public HttpMessageConverters httpMessageConverters() {
        HttpMessageConverter<?> customHttpMessageConverter = new CustomHttpMessageConverter();
        List<HttpMessageConverter<?>> additional = new ArrayList<>();
        additional.add(customHttpMessageConverter);
        HttpMessageConverters converters = new HttpMessageConverters(true, additional);
        return converters;
    }
    
}

> `HttpMessageConverters`有几个重载的构造方法，使用时可以参考对应的API文档选择合适的进行使用。

Spring Boot中拥有一个`HttpMessageConvertersAutoConfiguration`类，其会在未定义`HttpMessageConverters`类型的bean时，自动注册一个`HttpMessageConverters`类型的bean，即会通过它来使用默认的`HttpMessageConverter`。此外，其会在自动注册bean容器中定义的`HttpMessageConverter`，所以使用默认配置时也可以把需要注册的`HttpMessageConverter`定义为bean容器中的一个bean。`HttpMessageConvertersAutoConfiguration`中拥有一个`StringHttpMessageConverterConfiguration`类，会在bean容器中未定义`StringHttpMessageConverter`类型的bean时自动定义一个，使用的字符集默认是`UTF-8`，可以通过在`application.properties`中通过`spring.http.encoding.charset`指定。

## Converter和Formatter注册

下面的代码来自于`WebMvcAutoConfigurationAdapter`，从代码中可以看出Spring Boot会自动注册bean容器中定义的Converter和Formatter。

```java
@Override
public void addFormatters(FormatterRegistry registry) {
    for (Converter<?, ?> converter : getBeansOfType(Converter.class)) {
        registry.addConverter(converter);
    }
    for (GenericConverter converter : getBeansOfType(GenericConverter.class)) {
        registry.addConverter(converter);
    }
    for (Formatter<?> formatter : getBeansOfType(Formatter.class)) {
        registry.addFormatter(formatter);
    }
}
```

## 静态资源的处理

Spring Boot默认会把Classpath下的`/META-INF/resources/`、`/resources/`、`/static/`和`/public/`映射为静态资源路径。静态资源的相关配置由`ResourceProperties`类定义，对应的配置属性前缀是`spring.resources`。如果不想使用默认的静态资源位置，可以通过`spring.resources.static-locations`属性进行自定义。如果不需要把那些路径映射为静态资源路径，则可以设置`spring.resources.addMappings`的值为`true`。静态资源默认会映射为`/**`，即如果在`/resources`下拥有一个`index.html`文件，则可以通过`/index.html`请求到。可以通过`spring.mvc.static-path-pattern`指定静态资源映射的路径，下面代码就指定了静态资源的映射路径为`/resources/**`，`/**`对应的才是真实的静态资源的路径，所以此时如果需要请求`/resources`路径下的`index.html`文件，需要通过`/resources/index.html`才能请求到。

```properties
spring.mvc.static-path-pattern=/resources/**
```

更多配置信息可以参考`ResourceProperties`的源代码。

## 浏览器图标文件

Spring Boot默认会在配置的静态资源根路径下或者是Classpath根路径下寻找`favicon.ico`文件。

## Content Negotiation

Spring Boot默认是不支持后缀名匹配的，即请求`/report.json`时是不会被映射到`@GetMapping("/report")`的。可以通过如下方式指定支持后缀名匹配。

```properties
spring.mvc.contentnegotiation.favor-path-extension=true
```

关于Content Negotiation的可选配置都定义在`WebMvcProperties$Contentnegotiation.class`中。可以通过`spring.mvc.contentnegotiation.favor-parameter=true`指定支持通过查询参数指定请求类型，默认的查询请求类型查询参数是`format`，需要自定义时可以通过`spring.mvc.contentnegotiation.parameter-name`属性来指定。

## 内置容器可配置的属性

当使用内置的Web容器时可以针对内置容器进行一些自定义的配置，这些配置将由`org.springframework.boot.autoconfigure.web.ServerProperties`进行接收。常用的自定义配置包括`server.port`指定监听端口，`server.servlet.contextPath`指定contextPath，还可以通过`server.servlet.session.*`指定session相关的定义信息。下面的配置中定义了监听端口是8081,contextPath是`/app`，DispatcherServlet匹配的映射路径是`/web/*`，session的超时时间三30分钟，当指定session的超时时间时，如果不指定时间单位，默认单位是秒。

```properties
server.port=8081
server.servlet.context-path=/app
server.servlet.path=/web
server.servlet.session.timeout=30m
```

更多关于内置Web容器可配置的信息可以参考`org.springframework.boot.autoconfigure.web.ServerProperties`的API或源码。

## 注册Servlet/Filter等

根据Servlet3的规范，Classpath下的`@WebServlet`、`@WebFilter`和`@WebListener`标注的Class会被Web容器自动检测到，并进行注册。但是使用Spring Boot内置的Web容器时，它们是不会自动被检测到并被注册的。有两种方式可以在使用内置的Web容器时能够让它们进行自动注册。

### 定义为Spring bean

Spring Bean容器中的定义的Filter/Servlet和Listener会被自动注册，Filter会拦截所有请求，而Servlet的请求路径将是bean名称，然后需要以`/`结尾，比如下面代码中定义的Servlet的请求路径是`/hello/`。

```java
@Component("hello")
public class HelloServlet extends HttpServlet {

    /**
     * 
     */
    private static final long serialVersionUID = 8345578389259773375L;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        PrintWriter writer = resp.getWriter();
        writer.write("hello");
        writer.flush();
    }

}
```

> 需要注意的是当bean容器中只定义了一个Servlet时，该Servlet的映射路径不是bean名称，而是`/`。

### 通过`@ServletComponentScan`扫描



## 参考文档

[https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/html/boot-features-developing-web-applications.html#boot-features-embedded-container-servlets-filters-listeners](https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/html/boot-features-developing-web-applications.html#boot-features-embedded-container-servlets-filters-listeners)




（注：本文是基于Spring Boot 2.0.3所写）

