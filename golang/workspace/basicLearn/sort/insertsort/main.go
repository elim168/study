package main

import "fmt"

/**
 * 插入排序：
 * 思想：
 * 	每次把数据分为左右两部分，左边是有序的，右边是待排序的。每次从右边取一个数在左边去给它找一个待插入的位置。
 * 如果找的位置是在中间的，那么对应的数字后面的值是需要挪动位置的。
 原始数组为： [58 10 8 6 2 28]
第1次排序后的结果为：[10 58] [8 6 2 28]
第2次排序后的结果为：[8 10 58] [6 2 28]
第3次排序后的结果为：[6 8 10 58] [2 28]
第4次排序后的结果为：[2 6 8 10 58] [28]
第5次排序后的结果为：[2 6 8 10 28 58]
*/

func insertSort(nums []int) {

	// 第一个元素是有序的，从第二个元素开始遍历，给它找插入的位置
	for i := 1; i < len(nums); i++ {
		for j := i - 1; j >= 0; j-- {
			if nums[j+1] < nums[j] {
				// 当前要插入的数字比左边有序数字的最后一个数字小时先交换位置。换了位置后再跟左边的比较，直到找到一个不大于它的数字为止，则表示它落到了正确的位置上。
				nums[j+1], nums[j] = nums[j], nums[j+1]
			} else {
				break
			}
		}
		fmt.Printf("第%d次排序后的结果为：%v \n", i, nums)
	}

}

func printSort(nums []int) {
	fmt.Println("原始数组为：", nums)
	insertSort(nums)
	fmt.Println("进行了插入排序后的结果为：", nums)
}

func main() {
	printSort([]int{58, 10, 8, 6, 2, 28})
}
